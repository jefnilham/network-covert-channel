\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage[a4paper, total={6in, 10in}]{geometry} %default{6,8}
\usepackage[superscript,biblabel]{cite}
\usepackage{float}


% inlined bib file
\usepackage{filecontents}
\usepackage{hyperref}
\usepackage{array}
\usepackage{url}

\usepackage{paralist}
\usepackage{graphicx}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}


\hypersetup{
    colorlinks=true,
    citecolor=blue,
    urlcolor=blue,
    breaklinks=true
    }
    
\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}

%-------------------------------------------------------------------------------
\begin{document}
%-------------------------------------------------------------------------------

%don't want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Systems Security Report\\Design and Implementation of Network Covert Channels}

%for single author (just remove % characters)
\author{
{\rm Alan Leong Kah Wah}\\
\emph{Cyber Security Agency of Singapore}
\and
{\rm Jefnilham Bin Jamaludin}\\
\emph{Cyber Security Agency of Singapore}
\and
{\rm Matthew Cheong Kin Weng}\\
\emph{Cyber Security Agency of Singapore}
\and
{\rm Lee Ying Rong}\\
\emph{Cyber Security Agency of Singapore}
\and
{\rm Ho Yoke Yin}\\
\emph{Cyber Security Agency of Singapore}
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author


\maketitle

%-------------------------------------------------------------------------------
% \begin{abstract}
%-------------------------------------------------------------------------------
% Your abstract text goes here. Just a few facts. Whet our appetites.
% Not more than 200 words, if possible, and preferably closer to 150.
% \end{abstract}


\begin{abstract}
Network covert channels have typically been a way for hidden information to be communicated by exploiting vulnerabilities in current network protocol.By researching on covert channels, we would gain deeper insight on developing and implementing covert channels that would in turn help to create a stronger network infrastructure against such attacks.

The aim of our project is to present a Proof of Concept by designing and implementing network covert channels using Transmission Control Protocol (TCP) with proposed data hiding scenario(s), to ensure the non-detectability of covert channels.In our paper, we would discuss potential vulnerabilities in the current network infrastructure that could be exploited to establish the communication channel and showcase the functionality of our proposed covert channel model.
\end{abstract}





%-------------------------------------------------------------------------------
\section{Introduction}
%-------------------------------------------------------------------------------


\subsection{Background}

Unconventional methods of communication outside of the system’s protocol were coined by Butler W.Lampson to be called Covert Channels\cite{confinement}. As these types of communications lie outside what is to be expected they are stealthier and more secure compared to mainstream communication channels.

There are two broad classification of covert channels: storage channels and timing channels. Communication via storage channel requires the sender to store hidden data within some storage location, subsequently the hidden data would be retrieved by the receiver. Alternatively, communication via timing channels require the sender to signal information by means of controlling observable computational readings that could be translated to information for the receiver\cite{mdpi}.

The project will focus on developing a covert channel using the TCP network.

Noteworthy research on covert channel done over TCP/IP network would be Covert Channel Analysis and Data Hiding in TCP/IP by Kamran Ahsan\cite{kamran}. 

The work focused on developing and analysing the various methods that could be used in establishing covert channels using TCP/IP protocol. They covered some of the flaws and improvements that would be critical for improvement in network security infrastructure. In addition, they have created some novelty ways of covert channel using techniques such as packet sorting and packet header manipulation. 

Our paper aims to create alternatives to the methods provided and provide analysis on the effectiveness of the covet channel.  



\subsection{Objective}

The purpose of this paper is to deepen the understanding of the existing TCP/IP protocol by explaining in detail the various critical aspects of the protocol that could be in turn used in developing our communication channel. We would make use of the new insight to create a covert channel built upon the TCP protocol. 

We will do this specifically with storage channels within TCP, with out of order packets. If done correctly, we would have “innocent” network traffic which would be able to command an already infected machine with a payload.

\subsection{Motivation}

The motivation for this paper is to deepen our understanding in application and development of various covert channels. The deepened knowledge would expose possible limitations and restrictions which could be further studied and used in defending against malicious covert communication. 


%-------------------------------------------------------------------------------
\section{Internet Protocol and Transmission Control Protocol}

\subsection{IPv4}

The first internet protocol standard was published in RFC 791\cite{datatracker}. The internet protocol is responsible for encapsulating TCP segments and contains the IP address that would be used to identify the sender and the receiver for these particular packets. In a network setting, routers would decapsulate packets to get the IP address of the packets. Depending on the routing table, the packets could be dropped or encapsulated to be sent to the next network medium.

\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{ipv4header}
    \caption{IPv4 header}
\end{figure}

\subsection{TCP}

TCP is the transport layer which works in complement with the IP protocol. The TCP provides reliability to communication by providing reliability to the packets transferred between applications across the network\cite{rfceditor}. The application of TCP guarantees that the data transferred are error-less and in-sequence. Details of how this is achieved would be covered in the subsequent sub-chapters.

\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{tcpheader}
    \caption{TCP header}
\end{figure}

\subsection{TCP Reliability – Guaranteed and Ordered Delivery}

\subsubsection{Out-of-Order Delivery}
In standard data transferred via TCP we could observe a common observation of “out-of -order”. This phenomenon happens when during the transmission of a particular sequence of packets, the order of arrival is different from the order which it was sent out in. We observe that this particular observation is much more common for communication over the internet.

During data transfer, the data stream would be broken down into smaller packets. The packets. The packets would be sent off in sequence via routes that would be deemed most effective by each interim network medium to reach their destination. Upon receiving the packets, the end point would reassemble the packets back in the sequence that the data was supposed to be received in, completing the transfer of data. By the nature of TCP, we would be expecting data packets to travel in different routes resulting in packet loss and packet delays.

Hence, using this particular phenomenon as the spine of our covert channel development we would force packets to be out of order on purpose to signal a message via the sequence the packets arrive in. Other studies on subjects such as“Receive Index” and “Re-order judging Algorithm” will deepen our understanding on the concept of out-of-order delivery that would help with the development of the covert channel.

\subsubsection{Receive Index (RI)}

A received index is a value allocated to packets upon reaching their destination with regards to their sequence of arrival. The duplicated packets are not allocated received index and lost packets would result in received index not being assigned. If reordering is not needed, sequence number on arriving packets would be the same as the receive index allocated.

Generally, the receive index could be used to compute the time of an arriving packet, be it early or delayed.
The following examples display the usage of receive index common settings for a set of 6 packets.


\begin{lstlisting}[language=bash, frame=none]
Example 1:
Arrived sequence: 2 1 4 5 3 6
Receive index: 1 2 3 4 5 6

Example 2:
Arrived sequence: 1 4 3 5 3 5
Receive index: 1 3 4 5 - -
\end{lstlisting}

In the first example, there is no loss or duplication in packets, the packets are assigned a receive index as to how they arrive. However, in the second example, the packet with sequence number 2 is lost in transmission; hence ‘2’ is not assigned as an RI. Since Packet 3 and 5 are duplicates, the second copy arrived would not have an assigned RI.

The sequence of packets would be considered out-of-order if the receive index does not tally with the sequence number of the packets received. Duplicates, for which an RI is not defined, would be disregarded\cite{improvedpacket}.

\subsubsection{Reorder-judging Algorithm}

Generally, packets are considered out-of-order if the sequence number is smaller than the packet that was previously received by the receiver.  However, it is fully possible for network duplication, network reordering or retransmission to cause the packet to be considered out-of-order. Although the mentioned 3 causes are different in nature, for simplicity the only cause we would discuss would be network reordering.

Network reordering is normally a result of 2 factors: parallelism within the router or route change within the network\cite{packetreordering}. Figure 3 displays the reorder-judging algorithm, executed at the receiving end-point, which is based on TCP sequence number, IP ID and time lag.

\begin{figure}[htp]
    \centering
    \includegraphics[width=7cm]{reorderjudgingalgo.png}
    \caption{Process of the reorder-judging algorithm from A study of Internet Packet Reordering n.d., p4}
\end{figure}

Since TCP IP ID resets to 0 when incrementing to 65535, depending on the various states of different routing paths, we would be able to expect a different arrangement of IPID. Due to the fast retransmission algorithm, the time delay of a retransmitted packet must be much larger than a reordered packet for the algorithm to work as intended. 

Hence, it was set for a threshold of 300ms to the time lag to single out reordered packet from retransmitted packet with IPID wrapped\cite{packetreordering}.

%-------------------------------------------------------------------------------
\section{Design}

\subsection{Scenario}

We will act as an Advanced Persistent Threat (APT) already possessing active connections to the victim’s system. We will attempt communication with said victim while masquerading as legitimate traffic. 

We are successful if we are able to have undetectable communication with a victim machine, while being able to perform actions on objectives.

\subsection{Proposed Proof-of-Concept}

We built a client-server application for the covert channel communication. To simulate the covert channel, a webserver is first set up for the client’s entry.

TCP packets are sent when the client visits the website and performs various actions via Python, NFQueue and Scapy. NFQueue intercepts packets, shuffles, and delays them before transmitting the packets. Scapy allows the modification of packet fields.

If a packet is not needed for the covert channel, the packet would be ignored by the program. The receiver then reads each packet it receives, ideally looking out for signs that a packet has been modified by the sender, and piece together the hidden message.

\subsection{Manipulation of TTL Field in IP Header}

To assist in the interpretation of forced out-of-order TCP packets, we will be utilising the TTL field in the IP Header. We introduce a start and end identification to inform the server (receiver) that any packets in between could potentially be reordered.

With the help of the TTL field, the receiver can easily identify packets modified by the sender and interpret the covert message accordingly.

The TTL values utilised in the Proof-of-Concept are:

\begin{itemize}
  \item Start and End: 50
  \item Packet that should come first: 63
  \item Packet that should come later: 65
\end{itemize}

\subsection{Other settings/considerations}
\begin{compactitem}
  \item Sender to specify preferred route – Fixed routing
  \item In the interest of time, we are setting up the receiver as an already compromised system
\end{compactitem}

\subsubsection{Why TTL? Why not reserved bits?}
We wanted to make it hard to see any obvious outward tampering. Using reserve bits or any of the flag bits would immediately be noticeable by any IDS. Most IDS look at reserve bits because of common attacks like christmas tree attacks. Additionally, tampering with the reserved bits has already been done before in a prior research paper and we chose TTL in an attempt to try something new.

\subsubsection{Why TTL value of 50, 63 and 65?}
There is no definite answer to why the TTL values were selected. However, our decision was to use a value that is closer/similar to the TTL of Linux systems, which is 64. As our main system used for testing was an Ubuntu machine, we decided on 63 and 65 as the TTL values for packets that would potentially be reordered.

\subsubsection{Noise \& wrong message received}
Since we only have a local network proof of concept set up, it was hard to test for noise. That being said, our tolerance for noise will be low, and a single packet out of order or lost would break the message the receiver was meant to receive.


%-------------------------------------------------------------------------------

\section{Proof of Concept}

\subsection{Covert Channels via Out-of-Order TCP Packets}
We will now test the feasibility and detectability of our covert channel.

\subsubsection{Sending the Covert Message}
As previously mentioned, there is a client (sender) and a server (receiver). The sender uses a Python script (send.py) to create the NFQueue and message to send. The interface for the script is shown below.

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{1send.PNG}
    \caption{Script interface for send.py}
\end{figure}

Here, we are going to send a message of “111” bits to the receiver at IP address 192.168.137.130. Before the communication takes place, we must set up the receiver script to actively listen for TCP packets originating from the sender.

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{3recv.PNG}
    \caption{Output for send.py}
\end{figure}

Now, we will create the communication channel with an action that involves the TCP protocol. We initiate a simple file download from the receiver using the wget command in a separate terminal, as seen below.

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{2wget.PNG}
    \caption{File download as legit TCP communication}
\end{figure}

In the initial script terminal, we see the following output below that reorders the packets using NFQueue and Scapy. “1” signifies a reorder, “0” means no reorder.

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{1sendoutput.PNG}
    \caption{Output for packet reordering}
\end{figure}

Once the communication is complete, the receiver’s script is able to read the incoming packets and interpret the message accordingly to receive the bits of “111”.

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{3recvbits.PNG}
    \caption{Message corresponding to bit order received}
\end{figure}

In this scenario, the bits of “111” signifies the next course of action which is “Attack at dawn”.

\subsubsection{Detection of the Covert Channel}
Using Wireshark to perform live network traffic capture, we were able to log down all the packets involved in the communication for the covert channel. Below is a screenshot of the network traffic at a glance. It does not explicitly indicate that there are any suspicious/malformed packets logged.

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{alan1.PNG}
    \caption{Wireshark capture of network traffic}
\end{figure}

Diving deeper into the pcap analysis, we are able to discover the packets modified by our Python script (send.py).

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{alan2.PNG}
    \caption{Analysing packets modified by send.py: First modified packet}
\end{figure}

The above screenshot is the first packet modified by our script. The TTL field is set to 50 to inform the receiver that this is the starting point for any potential packet reorder. Next, we search for TTL values of 63 (packet that should come first) and 65 (packet that should come after the packet with a TTL value of 63). 

Below, we have our next modified packet with a TTL value of 65, meaning that the next modified packet in the list should contain a TTL value of 63, and an acknowledgement number that is smaller than the one seen.

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{alan3.PNG}
    \caption{Next (second) packet modified by send.py}
\end{figure}

The next modified packet’s information can be seen below.

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{alan4.PNG}
    \caption{Next (third) packet modified by send.py}
\end{figure}

As mentioned previously, we see a TTL value of 63, and an acknowledgement number of 24617 which is smaller than the acknowledgement number of 39097 of the previously modified packet. This means that the packets were forcefully reordered.

Although the packet information has its Total Length field highlighted in red, it is not immediately obvious to the analyst when reviewing logs at a glance.

Once all modified packets with TTL values of 63 and 65 are done transmitting, we end off the communication to the receiver by sending the last modified packet with a TTL value of 50 (similar to the start).

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{alanlast.PNG}
    \caption{Last packet TTL = 50 modified by send.py}
\end{figure}

\subsubsection{Summary/Learning Points}
This demonstration successfully proves that forceful reordering of packets is not detectable and explicitly flagged by common network traffic analysis tools such as Wireshark. 

Additionally, even if the communication channel was to be discovered, it is impossible to determine what information is being sent, given that the send.py Python script only reveals how the communication is executed and the possible encoded message sent. The decoding of the message can only be done on the receiver’s side.

\subsection{Covert Channels via Covert\_TCP}

Covert\_TCP is another proof of concept for exploitation of covert channels using the TCP/IP protocol suite devised by Craig Rowland\cite{monday}. 

The Covert\_TCP program manipulates the TCP/IP header of the data packets to send a file one byte at a time from any host to a destination. It can act like a server as well as a client and can be used to hide the data transmitted inside an IP header.

\subsubsection{Create a covert channel to send a text document from a client (sender) to a server (receiver)}

Both sender and receiver run the covert\_tcp program, covert\_tcp.c, that uses raw sockets to construct forged packets and encapsulate data from a filename given on the command line. The file itself can contain text or binary data as necessary. The message we are sending is “Secret Message”.

On the receiver with IP address 10.10.10.9, We run the program to start a listener to listen for packets from the sender using the following command:

\begin{lstlisting}[language=bash, frame=none]
./covert_tcp -dest 10.10.10.9 -source 10.10.10.13 -source_port 9999 -dest_port 8888 -server -file /home/ubuntu/Desktop/Receive/receive.txt
\end{lstlisting}

It will receive the data and save to the destination file given on the command line. 

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{yy1.png}
    \caption{Start a listener}
\end{figure}

On the sender with IP address 10.10.10.13, create a message.txt file containing the string “Secret Message” at \lstinline{/home/attacker/Desktop/Send} folder.

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{yy2.png}
    \caption{Create message.txt}
\end{figure}

Now, we will start sending the contents of message.txt file over tcp using the following command.

\begin{lstlisting}[language=bash, frame=none]
./covert_tcp -dest 10.10.10.9 -source 10.10.10.13 -source_port 8888 -dest_port 9999 -file /home/attacker/Desktop/Send/message.txt 
\end{lstlisting}

The covert\_tcp program starts sending the string one character at a time, as shown below.

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{yy3.png}
    \caption{Send one character at a time}
\end{figure}

On the receiver, the message is being received, one character at a time.

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{yy4.png}
    \caption{Receive one character at a time}
\end{figure}

Navigate to \lstinline{/home/ubuntu/Desktop/Receive} folder and double-click the receive.txt file to view its contents. It shows the full message saved in the file.

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{yy5.png}
    \caption{receive.txt}
\end{figure}

\subsubsection{Detection of the Covert Channel}

Using Wireshark to perform packet capture, we logged all the packets involved in the communication for the Covert\_TCP covert channel. Below is a screenshot of the network traffic with a display filter, “tcp”, showing many suspicious/malformed packets logged.

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{yy6.png}
    \caption{Wireshark capture of network traffic}
\end{figure}

Upon analysis, we find each character of the message string being sent in individual packets over the network. The covert\_tcp program utilizes the identification field of the IP protocol and replaces it, one character at a time, with the characters of the string to send the message.

Below are sample packets showing characters “S”, “e”, “c”, “r”, “e” and “t” in the IP identification field respectively, for the string “Secret”.
\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{yy7.png}
    \caption{Character “S”}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{yy8.png}
    \caption{Character “e”}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{yy9.png}
    \caption{Character “c”}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{yy10.png}
    \caption{Character “r”}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{yy11.png}
    \caption{Character “e”}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=7cm]{yy12.png}
    \caption{Character “t”}
\end{figure}

\subsubsection{Summary/Learning Points}

This demonstration of a covert channel using Covert\_TCP utilizes the IP identification field. Using common network traffic analysis tools such as Wireshark, it is relatively easy to spot suspicious/malformed packets. Moreover, the program is very slow in transmitting data (about one packet per second). The transfer rate is limited to one packet per second to ensure packets do not arrive out of sync. 

It requires proper decoding at the remote end and is painstakingly slow as each bit of information needs to be sent one packet at a time. Because we are subjugating the TCP/IP protocol for a purpose not designed, the normal reliability modes are non-existent and in essence functions much like UDP.


%-------------------------------------------------------------------------------
\section{Evaluation and Findings}

\subsection{Comparison}

We can see that Covert\_TCP can be improved on as it is easily detectable on wireshark and the message hidden within the packets can be found. In comparison it can hold more data compared to our out-of-order method, but since Covert\_TCP is so detectable, even without any specialized wireshark filters, we can’t really call it covert.


\subsection{Limitations}

\subsubsection{Out-of-order Packets}

A big limitation of this method is that within the script we had to manually increase the amount of packets with more if else statements. This made it tedious to increase the size of the data we could send.

Another limitation is that due to TTL being the starting signal for the program, it CANNOT be a default value, as our receiver would not be able to distinguish it from normal traffic. If the receiving network were to block any odd TTL values other than default this would immediately hit a wall.

\subsubsection{Covert\_TCP}

As we can see from the proof of concept, a big limitation to covert channels is sizing and timing. As the message size becomes longer, it becomes harder and harder to send more data without being discovered or suspicious.

Certain applications like Wireshark also automatically flag packets when using Covert\_TCP, making sustained communication difficult, however it is still hard to figure out what is going on unless one can correctly guess a covert channel attack.

\subsubsection{Both Methods}

The final and biggest limitation is that both methods require an already compromised listener to be able to receive messages. This means that while covert channels can maintain a harder to detect connection, the initial compromise might still raise alarms.

\subsection{Future Enhancements}

\subsubsection{IPv6}

Right now this project is not compatible with IPv6, however we could add IPv6 compatibility. It would require a bit of overhaul, as IPv6 headers are different from IPv4 headers.

\subsubsection{Command and Control}

Our receiving script currently only prints whether it was successful or not. We could extend this functionality to run specified scripts that have been placed prior or run a specific file if receiving a certain order of packets.

\subsubsection{Obfuscation}

Another enhancement that can be performed is obfuscation. As the messages are already hard to decipher, we will instead be obfuscating the callback IP, further reducing traceability.

\subsubsection{Noise}

As mentioned earlier, we have no real tolerance for noise. An enhancement or fix for this would be to have redundancies in place to handle packet loss or if noise corrupts the message. This would still be hard to implement, as the amount of bits we have is so small, it would be hard to use any for redundancies or checksums.

%-------------------------------------------------------------------------------
\section{Conclusion}

Not a lot of research and analysis has gone into covert channels. However, as is the norm in cyber security, it is quite possible to discover more ways to exploit the current system.

With our proof of concept in out-of-order packets, it can be used as another tool to disguise command and control commands to look like regular traffic, concealing the involvement with the victim machine.

%-------------------------------------------------------------------------------


\bibliographystyle{unsrt}
\def\UrlBreaks{\do\/\do-}
\bibliography{biblio.bib}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks